Day #12:
-----------
13 participants present at 09:00
-----------------------------------------
Spring Boot & Spring REST,Spring Data,Spring Test and API Documentation

Spring Boot – starters, Autoconfiguration, actuators, devtools, thymeleaf views, Spring REST – introduction, advantages, Spring REST – implementing REST and HTTP methods, case study demo with all methods.

Spring Data JPA, CRUD operations and simple queries, Relationships (one to one, one to many etc.,)

Spring Test – unit testing (repository, API, Service), Mocking, Introduction to OpenAPI, OpenAPI Specification (OAS), API Documentation, API Paths and Operations, Request and Response Objects, Data Models and Schemas, Security Definitions

We already learned to create RESTful webservices.
in RESTful webservice (REST API), 
we used Spring data JPA

in JPA,
Relationship between entities.
When I create multiple entities, then multiple tables are created by hibernate/jpa.
Among these multiple tables, there can be relationships.
Can you tell me, how 2 tables can have relationship?
---------------------------------------------------------------------
Anil says, "id?"
i ask, "How?"

such a simple questions, nobody is answering.

2 tables can have relationship using "Foreign key"

A table has a foreign key that references the primary key of another table.

The participants have not gone through the  SQL chapters in techademy.
They don't know foreign key.

tell me what is correct w.r.t Employee to Department
a) 1 to M
b) M to 1		(correct)
c) M to M
d) 1 to 1


example for M to M
	CUSTOMER vs PRODUCTS		in ecommerce


Many customer purchase many product

many to many is either side of one to many and many to one

1 customer purchase many product
1 product purchased by many customer

many to many often produces the relationship as an enitity

CUSTOMER		SALES		PRODUCT


Relationship SALES becomes a new entity

CUSTOMER -> SALES
PRODUCT -> SALES



@ManyToOne
	Whenever an annotation ends with "One"
	you dont need to do anything

@OneToMany
	whenever it ends with "Many" there is a problem
	hibernate will tend to create a new table whenever annotation ends with "Many"





Demo:
---------
we will create a rest api that exihibits relationship between entities.

1) Employee
2) Department

relationship between these 2 entities:
	1 Department has Many Employees
in other way
	Many Employees belong to 1 Department

Steps:
1) Create a spring boot application using spring initializr
	https://start.spring.io

	19-jun-relationship
	Maven
	jar
	java 17
	group: com.wipro.demo
	artifact: 19-jun-relationship
	package: com.wipro.demo

dependencies:
	Spring web
	Spring data jpa
	mysql driver

Finish.

2) application.properties:
	server.port=5000
	spring.application.name=19-jun-relationship

spring.datasource.url=jdbc:mysql://localhost:3306/wipro5
spring.datasource.username=root
spring.datasource.password=

spring.datasource.hikari.connection-timeout=20000
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.maximum-pool-size=12
spring.datasource.hikari.idle-timeout=300000
spring.datasource.hikari.max-lifetime=1200000

spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQLDialect
spring.jpa.properties.hibernate.id.new_generator_mappings = false
spring.jpa.properties.hibernate.format_sql = false
spring.jpa.hibernate.ddl-auto=update
spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl

logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE

3) create the entity classes with hibernate annotations
package com.wipro.demo.entity;

import java.util.List;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.OneToMany;

@Entity
public class Department {
	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	private Integer id;
	private String  name;
	private Long budget;
	@OneToMany(mappedBy = "department") //mappedBy will prevent creating new table	(is used whenever annotation ends with "Many")
	private List<Employee> employees;
	
	public Department() {}

	public Department(Integer id, String name, Long budget) {
		super();
		this.id = id;
		this.name = name;
		this.budget = budget;
	}

	public Integer getId() {
		return id;
	}

	public void setId(Integer id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Long getBudget() {
		return budget;
	}

	public void setBudget(Long budget) {
		this.budget = budget;
	}

	
	public List<Employee> getEmployees() {
		return employees;
	}

	public void setEmployees(List<Employee> employees) {
		this.employees = employees;
	}

	@Override
	public String toString() {
		return "Department [id=" + id + ", name=" + name + ", budget=" + budget + "]";
	}
	
}


package com.wipro.demo.entity;

import java.util.Date;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToOne;

@Entity
public class Employee {
	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	private Integer id;
	private String name;
	private Date dateOfJoining;
	private Integer salary;
	@ManyToOne
	private Department department;	//this is foreign key
	
	public Employee() {}

	public Employee(Integer id, String name, Date dateOfJoining, Integer salary, Department department) {
		super();
		this.id = id;
		this.name = name;
		this.dateOfJoining = dateOfJoining;
		this.salary = salary;
		this.department = department;
	}

	public Integer getId() {
		return id;
	}

	public void setId(Integer id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Date getDateOfJoining() {
		return dateOfJoining;
	}

	public void setDateOfJoining(Date dateOfJoining) {
		this.dateOfJoining = dateOfJoining;
	}

	public Integer getSalary() {
		return salary;
	}

	public void setSalary(Integer salary) {
		this.salary = salary;
	}

	public Department getDepartment() {
		return department;
	}

	public void setDepartment(Department department) {
		this.department = department;
	}

	@Override
	public String toString() {
		return "Employee [id=" + id + ", name=" + name + ", dateOfJoining=" + dateOfJoining + ", salary=" + salary
				+ ", department=" + department.getName() + "]";
	}
	
}



4) create the repositorys
package com.wipro.demo.repository;

import org.springframework.data.jpa.repository.JpaRepository;

import com.wipro.demo.entity.Department;

public interface DepartmentRepository extends JpaRepository<Department, Integer>
{

}

package com.wipro.demo.repository;

import org.springframework.data.jpa.repository.JpaRepository;

import com.wipro.demo.entity.Employee;

public interface EmployeeRepository extends JpaRepository<Employee, Integer>
{

}


5) create the services
package com.wipro.demo.service;

import java.util.List;
import java.util.Optional;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.wipro.demo.entity.Department;
import com.wipro.demo.repository.DepartmentRepository;

@Service
public class DepartmentService {
	@Autowired
	private DepartmentRepository dr;
	
	public Department create(Department department) {
		return dr.save(department);
	}
	public List<Department> read() {
		return dr.findAll();
	}
	public Department read(Integer id) {
		Optional<Department> temp = dr.findById(id);
		Department d=null;
		if(temp.isPresent())
		{
			d=temp.get();
		}
		return d;
	}
	public Department update(Department department) {
		Department temp = read(department.getId());
		if(temp!=null)
		{
			temp=department;
			dr.save(temp);
		}
		return temp;
	}
	public Department delete(Integer id) {
		Department temp = read(id);
		if(temp!=null)
		{
			dr.save(temp);
		}
		return temp;		
	}
	

}



package com.wipro.demo.service;

import java.util.List;
import java.util.Optional;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.wipro.demo.entity.Employee;
import com.wipro.demo.repository.EmployeeRepository;

@Service
public class EmployeeService {
	@Autowired
	private EmployeeRepository er;
	
	public Employee create(Employee employee) {
		return er.save(employee);
	}
	public List<Employee> read() {
		return er.findAll();
	}
	public Employee read(Integer id) {
		Optional<Employee> temp = er.findById(id);
		Employee d=null;
		if(temp.isPresent())
		{
			d=temp.get();
		}
		return d;
	}
	public Employee update(Employee employee) {
		Employee temp = read(employee.getId());
		if(temp!=null)
		{
			temp=employee;
			er.save(temp);
		}
		return temp;
	}
	public Employee delete(Integer id) {
		Employee temp = read(id);
		if(temp!=null)
		{
			er.save(temp);
		}
		return temp;		
	}
	

}

6) create the controllers
package com.wipro.demo.controller;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.wipro.demo.entity.Department;
import com.wipro.demo.service.DepartmentService;

@RestController
@RequestMapping("/department")
public class DepartmentController {
	@Autowired
	private DepartmentService ds;
	
	@PostMapping
	public Department create(@RequestBody Department department) {
		return ds.create(department);
	}
	
	@GetMapping
	public List<Department> read() {
		return ds.read();
	}
	
	@GetMapping("/{id}")
	public Department read(@PathVariable("id") Integer id) {
		return ds.read(id);
	}
	
	@PutMapping
	public Department update(@RequestBody Department department) {
		return ds.update(department);
	}
	
	@DeleteMapping("/{id}")
	public Department delete(@PathVariable("id")Integer id) {
		return ds.delete(id);
	}
	
}


package com.wipro.demo.controller;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.wipro.demo.entity.Employee;
import com.wipro.demo.service.EmployeeService;

@RestController
@RequestMapping("/employee")
public class EmployeeController {
	@Autowired
	private EmployeeService es;
	
	@PostMapping
	public Employee create(@RequestBody Employee employee) {
		return es.create(employee);
	}
	
	@GetMapping
	public List<Employee> read() {
		return es.read();
	}
	
	@GetMapping("/{id}")
	public Employee read(@PathVariable("id") Integer id) {
		return es.read(id);
	}
	
	@PutMapping
	public Employee update(@RequestBody Employee employee) {
		return es.update(employee);
	}
	
	@DeleteMapping("/{id}")
	public Employee delete(@PathVariable("id")Integer id) {
		return es.delete(id);
	}
	
}


7) use postman to test them:
add a department first
and find the id generated for that department and use it while adding employee

add an employee in department "5" using:
{
	"name":"Suresh",
	"dateOfJoining":"2010-08-16",
	"salary":"100000",
    "department":{"id":5}
}

---------------------------
Task:
Create a REST api with following entities:

	Product
	Category

M products belongs to 1 category
1 category has M products

complete this and push to git and share the git url when i ask
